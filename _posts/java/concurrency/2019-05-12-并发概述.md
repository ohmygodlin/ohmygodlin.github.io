---
layout: post
title: "并发概述"
date: 2019-05-12 16:33:16 +0800
description: ""
category: java/concurrency
tags: []
---

Java中实现高并发是基于多线程编程的，所谓并发，也就是多个线程同时工作，来处理我们的业务。线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。 

## 优点

- 充分利用多核CPU的计算能力
- 方便进行业务拆分，提升应用性能

## 缺点

#### 频繁的上下文切换

- 无锁并发编程：可以参照concurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间
- CAS算法，从Java5开始，利用Atomic下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换
- 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态
- 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

####  线程安全问题

多个线程同时但以不同的顺序请求临界区锁的时候，容易引起死锁。可以通过jps，jstack验证死锁是否存在。避免死锁的方式：

- 避免一个线程同时获得多个锁
- 避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源
- 所有的线程都按照相同的顺序获得锁
- 尝试使用定时锁，使用lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞，线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试
- 死锁检测，针对那些不可能实现按序加锁并且锁超时也不可行的场景，检测到死锁后：1、释放所有锁，回退，并且等待一段随机的时间后重试；2、给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况

 参考：

[并发编程的优缺点](https://juejin.im/post/5ae6c3ef6fb9a07ab508ac85)

[避免死锁](http://ifeve.com/deadlock-prevention/)

