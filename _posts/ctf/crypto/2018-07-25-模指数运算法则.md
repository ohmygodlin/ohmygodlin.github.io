---
layout: post
title: "模指数运算法则"
date: 2018-07-25 11:09:36 +0800
description: ""
category: ctf/crypto
tags: [RSA]
mathjax: true
---

#### [费马小定理](https://blog.csdn.net/butterfly9844/article/details/77899533)

若p是素数，q是正整数且不能被p整除，则：

$$
q^{(p-1)} \% p = 1
$$

推论：若p是素数，q是正整数且不能被p整除，则：

$$
q^{(p-1)} * q \% p = q^{(p-1)} \% p = 1 * q \%p = q \% p
$$

##### 引理一，[剩余系定理2](https://iask.sina.com.cn/b/20829452.html)：当jq%p = kq%p，如果q和p互素，有j%p=k%p。

证明：

由于：jq %p = kq %p，有：(jq-kq)%p = 0，可得：(j-k)q%p = 0，即：(j-k)q = np，由于q和p互素，只能够n=xq，因此q可以约去，得：(j-k)%p=0，即j%p=k%p

证明：

依赖集合相等的思想。考虑小于p的正整数集合Y={1,2,...,p-1}，用q乘以集合中所有元素并对p取模，得到集合X={q%p, 2q%p, ..., (p-1)q%p}，因为p不能整除q，因此X的元素都不等于0，而且各元素不相等（反证法：假设jq%p=kq%p，其中0<j<k<p，根据引理一，有j%p=k%p，因为j，k都是小于p的正整数，与假设不符，得证）。所以X和Y构成相同，只是元素顺序不同，将两个集合元素分别相乘，并对结果模p，得：

$$
X = q*2q*...*(p-1)q \% p = q^{(p-1)}(p-1)! \% p = Y = 1*2*...*(p-1) \% p = (p-1)! \% p
$$

因为(p-1)!和p互素，根据引理一，可以约去(p-1)!，得证：

$$
q^{(p-1)} \% p = 1
$$

推导1：

$$
q^{(p-1)} = np + 1\\q^{(p-1)} * q = (np+1)q\\q^{p} = npq + q\\q^p \% (p*q) = q
$$

推导2，p，q均为素数：

$$
(p+q)^{(p+q)} \% (p*q) = (p^{(p+q)} + np^iq^j+... + q^{(p+q)}) \% (p*q) \\= (p^{(p+q)} + q^{(p+q)}) \%(p*q) //p^iq^j可以被p*q整除\\=(p^p*p^q + q^q*q^p)\%(p*q)\\=(p^p*p + q^q * q) \%(p*q) //推导1\\=(p^{(p+1)} + q^{(q+1)}) \% (p*q)
$$

推导3：

$$
p^p \% q = x\\设:p^p = n * q + x\\p^p * p = n * p * q + x*p\\p^{(p+1)} = n * p * q + (p^p\%q) * p\\p^{(p+1)} \% (p*q) = (p^p\%q) *ｐ//p^p\%q小于q，因此乘积小于p*q，无需再模(p*q)
$$

以模指数pow(p,e,n)形式表示，要求指数为素数，底是正整数且不能被指数整除：

$$
pow(p, q-1, q) = 1\\pow(p, q, q) = p\\pow(p, q, p*q) = p\\pow(p+q, p+q, p*q) = (pow(p, p+1,p*q) + pow(q, q+q, p*q)) \% (p*q)\\pow(p, p+1,p*q) = pow(p, p, q) * p
$$

