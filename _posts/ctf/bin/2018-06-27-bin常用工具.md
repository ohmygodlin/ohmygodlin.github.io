---
layout: post
title: "bin常用工具"
description: ""
category: ctf/bin
tags: []
---
```sh
upx -d file #脱壳
./checksec --file file #检查程序打开的保护
disasm 4839dd -c amd64 #将16进制字串反汇编
strace/ltrace #查看系统调用
```
## 生成固定长度攻击字串及计算偏移 ##
1. 使用pwntools里面的cyclic工具（仅限32bit）
```sh
# cyclic 150
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma
# cyclic -l 0x6261616b
140
```
2. 使用pattern.py（32bit/64bit通用）
```sh
# python pattern.py create 150 > input
# python pattern.py offset 0x3765413665413565
hex pattern decoded as: e5Ae6Ae7
136
```

## 打开系统coredump
```sh
ulimit -c unlimited #把core文件的大小设置为无限大
sh -c 'echo "/tmp/core.%t" > /proc/sys/kernel/core_pattern' #设置输出core文件名格式
```

## readelf
```sh
readelf -S level2 #获取各段地址，如.bss
readelf -s level2 #从符号表中查symbols
```

## objdump
```sh
objdump -d -j .plt level2 #查看plt表
objdump -R level2
objdump -d level2 | grep pop -C5 #查pop相关gadget
```

## ROPgadget
```sh
ROPgadget --binary level2 --only "pop|ret"
```

## IDA
1.sp-analysis failed，调用栈不平衡
Option->General->Disassembly, 将选项Stack pointer打勾
观察每条call sub_xxxxxx前后的堆栈指针是否平衡
```assembly
.text:0000000000000F5A 020                 xor     eax, eax
.text:0000000000000F5C 020                 jz      short loc_F62
.text:0000000000000F5E 020                 add     rsp, 4
.text:0000000000000F62
.text:0000000000000F62     loc_F62:  
.text:0000000000000F62 01C                 pop     rax
```
由于xor eax,eax一定会引起跳转，因此F5E处的add rsp,4可认为是花指令，选中F5E 的add rsp, 4，右键
- Fill with NOPs（推荐）
- change stack pointer(alt+K)，将0x4修改为0x0
按D再按C键刷一下函数定义

2.查找函数调用关系
View -> Open subview -> Function calls
上半部分列出所有调用当前函数的位置，下半部分列出当前函数调用的别的函数

## gdb
1.断点
```
b *0x4071af
i b
delete 1
```
2.跟踪访问
```
awatch (char)0x7fff40aaf  硬件内存访问（读写）断点
rwatch                                    读断点
watch                                     写断点
```
3.修改内存/寄存器
```
set $cl=0x23
set (char)0x7ffff40aaf=0x23
```
4.查看内存
```
x/10gx 以8字节按16进制显示10个值
x/10wx 以4字节按16进制显示10个值
```

## pwndbg
1.参考[调教gdb](http://veritas501.space/2018/03/27/%E8%B0%83%E6%95%99pwndbg/)
```sh
cd ~/Download/pwndbg
vi pwndbg/commands/heap.py  
```
- 使得heap命令打印chunk的时候prevsize和size显示为16进制，将def malloc_chunk(addr):倒数第二行print(header, chunk["value"])修改为：
```python
    ## edit start
    chunk_str='{\n'
    for key in chunk["value"].type.keys():
        chunk_str+='  %s = %s,\n'%(str(key),hex(int(chunk["value"][key])))
    chunk_str+='}'
    print(header, chunk_str)
    ## edit end
```
- 加入fake_fastbin_all函数：
```python
@pwndbg.commands.ParsedCommand
@pwndbg.commands.OnlyWhenRunning
def fake_fastbin_all(addr):
    """
    Finds candidate fake fast chunks that will overlap with the specified
    address. Used for fastbin dups and house of spirit
    """
    main_heap = pwndbg.heap.current
    max_fast = main_heap.global_max_fast
    max_idx  = main_heap.fastbin_index(max_fast)
    start    = int(addr) - int(max_fast)
    mem      = pwndbg.memory.read(start, max_fast, partial=True)
    fmt = {
        'little': '<',
        'big': '>'
    }[pwndbg.arch.endian] + {
        4: 'I',
        8: 'Q'
    }[pwndbg.arch.ptrsize]
    print(C.banner("FAKE CHUNKS"))
    for idx in range(max_idx +1):
        if pwndbg.arch.ptrsize == 8:
            print(message.hint(hex((idx+2)<<4))+": ")
        else:
            print(message.hint(hex((idx+2)<<3))+": ")
        for offset in range(max_fast - pwndbg.arch.ptrsize):
            candidate = mem[offset:offset + pwndbg.arch.ptrsize]
            if len(candidate) == pwndbg.arch.ptrsize:
                value = struct.unpack(fmt, candidate)[0]
                if main_heap.fastbin_index(value&0xffffffff) == idx:
                    print('[+]',hex(start+offset-pwndbg.arch.ptrsize),', padding len:',hex(int(addr)-start-offset-pwndbg.arch.ptrsize))
```

2.查找fast chunk
```
find_fake_fast 0x602000 0x7f
fake_fastbin_all 0x7f690516ab10 （需要按上一步操作先加入fake_fastbin_all函数）
```

3.找rop，一般由ROPgadget代替
```sh
rop --grep "pop edi" -- --nojop -nosys --depth 2
```

4.查找数值或字符串
```sh
search -p 0x74d10df00
search -s flag
```

5.直接计算数值
```sh
print /x 0x7fd798586b10-0x7fd798586aed
$2 = 0x23
```

6.查看各段地址和权限
```sh
vmmap
0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
```
