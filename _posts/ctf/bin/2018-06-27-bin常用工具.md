---
layout: post
title: "bin常用工具"
description: ""
category: ctf/bin
tags: []
---
```sh
upx -d file #脱壳
./checksec --file file #检查程序打开的保护
disasm 4839dd -c amd64 #将16进制字串反汇编
strace/ltrace #查看系统调用
python -c "print 'A' * 96 + '\x04\xa0\x04\x08' + str(0x80485e3)" | ./passcode #python -c cmd，直接输出重定向到程序
```
## 生成固定长度攻击字串及计算偏移 ##
#### 使用pwntools里面的cyclic工具（仅限32bit）

```sh
# cyclic 150
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma
# cyclic -l 0x6261616b
140
```
#### 使用pattern.py（32bit/64bit通用）

```sh
# python pattern.py create 150 > input
# python pattern.py offset 0x3765413665413565
hex pattern decoded as: e5Ae6Ae7
136
```

## 打开系统coredump
```sh
ulimit -c unlimited #把core文件的大小设置为无限大
sh -c 'echo "/tmp/core.%t" > /proc/sys/kernel/core_pattern' #设置输出core文件名格式
```

## readelf
```sh
readelf -S level2 #获取各段地址，如.bss
readelf -s level2 #从符号表中查symbols
readelf -r level2 #读GOT表
```

## objdump
```sh
objdump -d -j .plt level2 #查看plt表
objdump -R level2
objdump -d level2 | grep pop -C5 #查pop相关gadget
```

## ROPgadget
```sh
ROPgadget --binary level2 --only "pop|ret"
```

## IDA
#### 修改binary

选中需要修改的字节，Edit->Patch program->Change byte（或者右键直接Fill with NOPs），然后Edit->Patch program->Apply patches to input file。

#### 反汇编界面

按D可以定义数据，按P可以变成函数，按U可以转成未定义，按C可以变成代码。 

#### sp-analysis failed，调用栈不平衡

Option->General->Disassembly, 将选项Stack pointer打勾
观察每条call sub_xxxxxx前后的堆栈指针是否平衡

```assembly
.text:0000000000000F5A 020                 xor     eax, eax
.text:0000000000000F5C 020                 jz      short loc_F62
.text:0000000000000F5E 020                 add     rsp, 4
.text:0000000000000F62
.text:0000000000000F62     loc_F62:  
.text:0000000000000F62 01C                 pop     rax
```
由于xor eax,eax一定会引起跳转，因此F5E处的add rsp,4可认为是花指令，选中F5E 的add rsp, 4，右键
- Fill with NOPs（推荐）
- change stack pointer(alt+K)，将0x4修改为0x0
按D再按C键刷一下函数定义

#### 查找系统调用

（G->输入GetWindowTextA）/（Ctrl+L，找到GetWindowTextA） -> X（Jump to cross ref）

Alt+T->输入GetWindowTextA，Find all occurences

#### 查找数据

Jump->Jump to segment（Ctrl+S），找.rdata（readONLY）和.data（writable）

View->Open subviews->String（Shift+F12）

#### 查找函数调用关系

View -> Open subview -> Function calls
上半部分列出所有调用当前函数的位置，下半部分列出当前函数调用的别的函数

#### 提取数据

View->Open Subviews->Strings，选中，Shift+E提取所有字符串数据

#### 反汇编界面显示字节码

Options->General->Number of opcode bytes (non-graph) : 8

#### 运行脚本

File->Script Command->auto i;for(i=0;i<0x61;i++){**PatchByte**(0xF21013+i, Byte(0xf21013+i)^90);}

#### please position the cursor within a function:

右键 creat func

#### [ida动态调试elf](https://www.52pojie.cn/thread-730499-1-1.html)

dbgsrv目录下的linux_server或者linux_serverx64放到linux中，运行，会监听端口，默认23946，IDA Debugger选Remote Linux debugger，设置：

Application=Inputfile=/mnt/shared/path/crackme

Directory=/mnt/shared/path

Hostname：填linux的Ip

IDA下断点，然后start process（注意attach process会报无权限）

## OllyDbg

#### [ESP定律脱壳](https://blog.csdn.net/wyt4455/article/details/8737670)

OEP（Original Entry Point）：程序的入口点 。当PE文件运行开始的时候，也就是进入壳的第一行代码的时候 ，寄存器的值和即将执行OEP的时候完全相同（除了EIP）。

根据经验，多数壳运行到OEP的时候，ESP=0012FFC4，而到达OEP之后，绝大多数的程序第一句都是压栈，因此**对0012FFC0下硬件断点**（右键->Breakpoint/Hardware,on execution，或者命令行键入：HW 12FFC0），即可以停在OEP的第二句，右击程序当前位置第一行代码，选择OllyDump脱壳调试进程。

内存断点不修改原代码，遇到代码校验（会导致INT3断点失败），硬件断点失灵的情况下，可以用内存断点代替：

- 内存断点等效与命令bpm，他的中断要用到DR0-DR7的调试寄存器，也就是说OD通过这些DR0-DR7的调试寄存器来判断是否断下
- 普通断点（F2下断）等效于bpx，他是在所执行的的代码的当前地址的一个字节修改为CC（INT3）。当程序运行到INT3的时候就会产生一个异常，而这个异常将交给OD处理，把这个异常的regEIP-1以后就正好停在了需要的中断的地方（这个根据系统不同会不一样），同时OD在把上面的int3修改回原来的代码。 

两次内存断点法，前提：壳的解码按code段，data段，rsrc段的顺序，因此假如data段或者rsrc段内存断点被触发，意味code段解码完成：

1. 对data段下内存访问（写入）断点 ，断在壳对data段的解压写入数据
2. 对code段下内存访问（执行）断点，断在执行OEP处

无法使用内存断点法的情况：

1. 像UPX和ASPACK这样当一个壳如果在JMP到OEP前的一行代码仍在对code段解压，就没必要使用内存断点
2. 在OEP处有stolen code的代码

ctrl+A 分析代码

右键反汇编窗口任意位置→复制到可执行文件→所有修改→全部复制

## gdb

#### 重定向输入

```
> r < input
```

#### 断点

```
b *0x4071af
b *main+209
i b
delete 1
```
#### 跟踪访问

```
awatch (char)0x7fff40aaf  硬件内存访问（读写）断点
rwatch                                    读断点
watch                                     写断点
```
#### 修改内存/寄存器

```
set $cl=0x23
set (char)0x7ffff40aaf=0x23
```
#### 查看内存

```
x/10gx 以8字节按16进制显示10个值
x/10wx 以4字节按16进制显示10个值
```

## pwndbg
#### 参考[调教gdb](http://veritas501.space/2018/03/27/%E8%B0%83%E6%95%99pwndbg/)

```sh
cd ~/Download/pwndbg
vi pwndbg/commands/heap.py  
```
- 使得heap命令打印chunk的时候prevsize和size显示为16进制，将def malloc_chunk(addr):倒数第二行print(header, chunk["value"])修改为：
```python
    ## edit start
    chunk_str='{\n'
    for key in chunk["value"].type.keys():
        chunk_str+='  %s = %s,\n'%(str(key),hex(int(chunk["value"][key])))
    chunk_str+='}'
    print(header, chunk_str)
    ## edit end
```
- 加入fake_fastbin_all函数：
```python
@pwndbg.commands.ParsedCommand
@pwndbg.commands.OnlyWhenRunning
def fake_fastbin_all(addr):
    """
    Finds candidate fake fast chunks that will overlap with the specified
    address. Used for fastbin dups and house of spirit
    """
    main_heap = pwndbg.heap.current
    max_fast = main_heap.global_max_fast
    max_idx  = main_heap.fastbin_index(max_fast)
    start    = int(addr) - int(max_fast)
    mem      = pwndbg.memory.read(start, max_fast, partial=True)
    fmt = {
        'little': '<',
        'big': '>'
    }[pwndbg.arch.endian] + {
        4: 'I',
        8: 'Q'
    }[pwndbg.arch.ptrsize]
    print(C.banner("FAKE CHUNKS"))
    for idx in range(max_idx +1):
        if pwndbg.arch.ptrsize == 8:
            print(message.hint(hex((idx+2)<<4))+": ")
        else:
            print(message.hint(hex((idx+2)<<3))+": ")
        for offset in range(max_fast - pwndbg.arch.ptrsize):
            candidate = mem[offset:offset + pwndbg.arch.ptrsize]
            if len(candidate) == pwndbg.arch.ptrsize:
                value = struct.unpack(fmt, candidate)[0]
                if main_heap.fastbin_index(value&0xffffffff) == idx:
                    print('[+]',hex(start+offset-pwndbg.arch.ptrsize),', padding len:',hex(int(addr)-start-offset-pwndbg.arch.ptrsize))
```

#### 查找fast chunk

```
find_fake_fast 0x602000 0x7f
fake_fastbin_all 0x7f690516ab10 （需要按上一步操作先加入fake_fastbin_all函数）
```

#### 找rop，一般由ROPgadget代替

```sh
rop --grep "pop edi" -- --nojop -nosys --depth 2
```

#### 查找数值或字符串

```sh
search -p 0x74d10df00
search -s flag
```

#### 直接计算数值

```sh
print /x 0x7fd798586b10-0x7fd798586aed
$2 = 0x23
```

#### 查看各段地址和权限

```sh
vmmap
0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so
```

#### 查看栈

```c
telescope $rsp
```

